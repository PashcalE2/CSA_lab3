# Размышления

https://wiki.osdev.org/X86-64_Instruction_Encoding

## Машинные команды CISC

Я надеюсь что должно хватить 16 бит для машинного слова.

**БУДЕТ BIG ENDIAN** потому что позволяет: 
- не преобразовывать данные между хранением и использованием
- все равно можно будет работать с байтами по адресу и словами по выровненному адресу
- все равно (наверно) будем декодировать по байтам

Одна операция кодируется переменным числом байт. Надо как-то устроить механику переменной длины.

### Например, LD (load)

```asm
; базовая адресация, может быть посчитана на этапе сборки 
; адрес = база
ld ac, [ptr] 
ld ac, [ffffh]
ld ac, [123+54*23/123] ; считается в число на этапе сборки

; со смещением - есть 1 операция сложения (вычитания)
; адрес = база + смещение
ld ac, [ptr + ac]

; индексная - есть 1 операция сложения (вычитания)
; адрес = база + индекс
; есть 1 операция умножения
; индекс = регистр * размер_в_байтах
ld ac, [ptr + ac * 1]

; индексная со смещением - есть 2 операция сложения (вычитания)
; адрес = база + индекс + смещение
; есть 1 операция умножения
; индекс = смещение * размер_в_байтах 
ld ac, [ptr + ac * 4 + rc]
```

- Наверно на все необходимые опкоды хватит 1 байт
- Наверно для команд которые могут принимать аргументы,
  необходима информация как получить аргументы (кратно байту):
    - 2 бит на код вида адресации = `00`, `01`, `10`, `11`
    - ? бит = что будет в первом операнде ()
    - ? бит = что будет во втором операнде
  
## Транслятор

Должен иметь несколько стадий: 
- понять что код написан синтаксически верно (нет ошибок в написании мнемоник, меток...) 
- подставить адреса меток на места их использования, вычислить математические выражения с числами
- и только теперь можно сказать что конкретная команда использует 
  арифметическое выражение, какую-то адресацию в операнде, 
  регистр -- можно уместить её в машинном коде
  
## Особенности реализованного asm

Нет необходимости стараться делать `section .code / .data` потому как архитектура фон-неймана --
память команд и данные есть одно устройство, и всё размещается только там

Так как у нас есть "работа со строками" и наводящий вопрос 
"а как разместить литерал который больше слова?" 
то придется вводить хотя бы три типа данных:
- byte
- word
- dword

Хотя если вопрос про литералы так же относится к строкам как к `dword`, 
то наверно хватит `byte` и `word`. 
Но они обязаны поддерживать массивы-перечисления и повторения `dup`!

Так что, пока реализуем только их. Для этого потребуется ввести подсказки для транслятора в виде:
- `{что-нибудь} byte {или тут}` -- эта инструкция в этом месте работает с байтом
- или без изменений -- со словом

## Директивы `byte` и `word`

Закодируем префиксом (специальный байт-код) для машинной команды. 
Соответственно, либо оба операнда `byte`, либо `word`

По-умолчанию `word`-префикс не пишется

```machine_code
< адрес  > <байт код (переменной длины)>
   1234     AB CD EF 01 23 45 67 89 AB
 
   0000     [Prefix] Opcode [ModRegMem Operands]
```

## Все необходимые инструкции и директивы

Почти как в БЭВМ, единственное что, добавим директивы `byte / times` и их корректное применение 

Короче можно `label byte data...` или `label times byte data...` или `instruction byte operand, operand`

```bnf

<org_directive> ::= "org" <address>

<type_op_directive> ::= <type_directive>

<byte_definition> ::= <label> <byte_directive> <byte_args>
<byte_directive> ::= "byte"

<no_arg_op> ::= "nop" | "halt" | 
                "clc" | "cmc" | "pushf" | "popf" |
                "ret" | "iret" |
                "ei" | "di"

<one_arg_op> ::= "not" | "neg" |
                 "inc" | "dec" |
                 "rol" | "ror" | "asl" | "asr" |
                 "sxtb" | "swab" |
                 "jmp" | "call" | <branch_op> |
                 "push" | "pop" |
                 "int"

<branch_op> ::= "jl" | "jle" | "je" | "jne" | "jg" | "jge" | "loop"

<two_arg_op> ::= "mov" | 
                 "and" | "or" | "xor" |
                 "add" | "adc" | "sub" | "cmp" | "swap" | "imul" | "idiv"
                 
<var_arg_op> ::= "poly" | 

```

Секций не будет, всё на усмотрение программиста через `org`.
Если `org` не использован, то по-умолчанию:
- `0000:000F` -- вектора прерываний 8 штук по 2 слова (адрес обработчика, program state) = 16 слов
- `0010:0011` -- эта память мапится на регистр состояния и регистр данных в размере по 1 байт для 1 "устройства ввода"
  `if op == load and address in inputs_addresses: operand = inputs[address - inputs_base].pop(0)` 
- `0012:0013` -- эта память мапится на регистр состояния и регистр данных в размере по 1 байт для 1 "устройства вывода"
  `if op == store and address in outputs_addresses: outputs[address - outputs_base].append(operand)`
- `0020:` -- программа или данные начинается тут и растет вперед
- `:FFFF` -- стек начинается тут и растет назад, `sp + 1` = предыдущий байт на стеке


## Ввод-вывод "trap"

На вход подается расписание ввода = `[(time, char), (time, char), ...]`

На машине идет отсчет времени каждую инструкцию (по варианту) -- выполнение инструкции состоит из этапов:
- Instruction fetch
- Address fetch
- Operand fetch
- Execution -- по сути тут выполнение инструкции закончено
- Interrupt -- тут проверяется есть ли прерывание и делаем что должно
- ради прикола будем увеличивать время после Interrupt

Если время больше или равно указанному в расписании, 
то **единственное** "устройство ввода" волшебным образом устанавливает значение в буфер (1 символ ха),
только если буфер еще не занят (комп уже обработал старый символ)
и оповещает о прерывании.

Пока машина выполняет, проверяет на прерывание:
- бежит прерываться
- запрещает прерываться
- читает по **захардкоженному** адресу устройства (и тут же снимает прерывание)
- работает, может пишет в 
  **захардкоженный** адрес <=> if op == store and addr == io_addr: buf += char (mda)
- разрешает прерываться
- возвращается из прерывания

